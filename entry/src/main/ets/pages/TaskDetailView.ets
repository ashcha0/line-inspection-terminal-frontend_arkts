import router from '@ohos.router';
import promptAction from '@ohos.promptAction';
import { HttpUtil } from '../utils/HttpUtil';
import { AppConstants } from '../constants/AppConstants';
import { FlawService, AgvFlaw } from '../services/FlawService';

// æ•…éšœçŠ¶æ€æšä¸¾
enum FlawStatus {
  PENDING = 'pending',
  CONFIRMED = 'confirmed',
  SUSPECTED = 'suspected',
  FALSE_POSITIVE = 'false_positive'
}

// ä½¿ç”¨FlawServiceä¸­çš„AgvFlawæ¥å£
type Flaw = AgvFlaw;

// ä»»åŠ¡æ¥å£
interface Task {
  id: number;
  taskNo: string;
  taskName: string;
  startLocation: string;
  endLocation: string;
  distance: number;
  creator: string;
  executor: string;
  status: string;
  createTime: string;
  startTime?: string;
  endTime?: string;
}

@Entry
@Component
struct TaskDetailView {
  @State task: Task | null = null;
  @State flaws: AgvFlaw[] = [];
  @State currentFlawIndex: number = 0;
  @State showFlawDetail: boolean = false;
  @State selectedFlaw: AgvFlaw | null = null;
  @State loading: boolean = true;
  @State confirmedCount: number = 0;
  @State flawRemark: string = '';
  @State isUpdatingFlaw: boolean = false;
  @State suspectedCount: number = 0;
  @State falsePositiveCount: number = 0;
  
  private taskId: number = 0;

  aboutToAppear() {
    const params = router.getParams() as Record<string, Object>;
    if (params && params['taskId']) {
      this.taskId = params['taskId'] as number;
      this.loadTaskDetail();
      this.loadFlaws();
    }
  }

  async loadTaskDetail() {
    try {
      const response = await HttpUtil.get(`/agv/task/${this.taskId}`);
      if (response.code === 200) {
        this.task = response.data as Task;
      }
    } catch (error) {
      console.error('åŠ è½½ä»»åŠ¡è¯¦æƒ…å¤±è´¥:', error);
    }
  }

  async loadFlaws() {
    try {
      console.info('[TaskDetailView] ğŸ” åŠ è½½æ•…éšœåˆ—è¡¨ï¼Œä»»åŠ¡ID:', this.taskId);
      
      const flawData = await FlawService.listFlaw({
        pageNum: 1,
        pageSize: 1000,
        taskId: this.taskId
      });
      
      this.flaws = flawData.rows || [];
      this.updateFlawCounts();
      
      console.info('[TaskDetailView] âœ… æ•…éšœåˆ—è¡¨åŠ è½½æˆåŠŸï¼Œæ•°é‡:', this.flaws.length);
    } catch (error) {
      console.error('[TaskDetailView] âŒ åŠ è½½æ•…éšœåˆ—è¡¨å¤±è´¥:', error);
    } finally {
      this.loading = false;
    }
  }

  updateFlawCounts() {
    this.confirmedCount = this.flaws.filter(f => f.confirmed === true).length;
    this.suspectedCount = this.flaws.filter(f => f.confirmed === false && f.remark?.includes('ç–‘ä¼¼')).length;
    this.falsePositiveCount = this.flaws.filter(f => f.confirmed === false && f.remark?.includes('è¯¯æŠ¥')).length;
  }

  selectFlaw(index: number) {
    this.currentFlawIndex = index;
  }

  openFlawDetail(flaw: AgvFlaw) {
    this.selectedFlaw = flaw;
    this.showFlawDetail = true;
    this.flawRemark = flaw.remark || '';
  }

  closeFlawDetail() {
    this.showFlawDetail = false;
    this.selectedFlaw = null;
    this.flawRemark = '';
    this.isUpdatingFlaw = false;
  }

  async updateFlawStatus(flawId: number, status: FlawStatus) {
    try {
      if (!this.selectedFlaw || this.isUpdatingFlaw) return;
      
      this.isUpdatingFlaw = true;
      console.info('[TaskDetailView] ğŸ”„ æ›´æ–°æ•…éšœçŠ¶æ€:', { flawId, status, remark: this.flawRemark });
      
      // æ ¹æ®çŠ¶æ€è®¾ç½®confirmedå’Œremark
      let confirmed: boolean;
      let remarkText = this.flawRemark.trim() || this.selectedFlaw.remark || '';
      
      switch (status) {
        case FlawStatus.CONFIRMED:
          confirmed = true;
          if (!remarkText.includes('ç¡®è®¤')) {
            remarkText = remarkText ? `${remarkText} [ç¡®è®¤æ•…éšœ]` : '[ç¡®è®¤æ•…éšœ]';
          }
          break;
        case FlawStatus.SUSPECTED:
          confirmed = false;
          if (!remarkText.includes('ç–‘ä¼¼')) {
            remarkText = remarkText ? `${remarkText} [ç–‘ä¼¼æ•…éšœ]` : '[ç–‘ä¼¼æ•…éšœ]';
          }
          break;
        case FlawStatus.FALSE_POSITIVE:
          confirmed = false;
          if (!remarkText.includes('è¯¯æŠ¥')) {
            remarkText = remarkText ? `${remarkText} [è¯¯æŠ¥]` : '[è¯¯æŠ¥]';
          }
          break;
        default:
          confirmed = false;
      }
      
      const updateData: Partial<AgvFlaw> = {
        id: this.selectedFlaw.id,
        taskId: this.selectedFlaw.taskId,
        round: this.selectedFlaw.round,
        flawType: this.selectedFlaw.flawType,
        flawName: this.selectedFlaw.flawName,
        flawDesc: this.selectedFlaw.flawDesc,
        flawDistance: this.selectedFlaw.flawDistance,
        flawImage: this.selectedFlaw.flawImage,
        flawImageUrl: this.selectedFlaw.flawImageUrl,
        flawRtsp: this.selectedFlaw.flawRtsp,
        shown: this.selectedFlaw.shown,
        uploaded: this.selectedFlaw.uploaded,
        createTime: this.selectedFlaw.createTime,
        flawLength: this.selectedFlaw.flawLength,
        flawArea: this.selectedFlaw.flawArea,
        level: this.selectedFlaw.level,
        countNum: this.selectedFlaw.countNum,
        deleteFlag: this.selectedFlaw.deleteFlag,
        confirmed: confirmed,
        remark: remarkText
      };
      
      await FlawService.updateFlaw(updateData);
      
      // æ›´æ–°æœ¬åœ°æ•°æ®
      const flawIndex = this.flaws.findIndex(f => f.id === flawId);
      if (flawIndex >= 0) {
        this.flaws[flawIndex].confirmed = confirmed;
        this.flaws[flawIndex].remark = remarkText;
        this.updateFlawCounts();
      }
      
      console.info('[TaskDetailView] âœ… æ•…éšœçŠ¶æ€æ›´æ–°æˆåŠŸ');
      
      this.closeFlawDetail();
      
      setTimeout(() => {
        try {
          promptAction.showToast({
            message: 'æ•…éšœçŠ¶æ€æ›´æ–°æˆåŠŸ',
            duration: 2000
          });
        } catch (toastError) {
          console.warn('[TaskDetailView] âš ï¸ Toastæ˜¾ç¤ºå¤±è´¥:', toastError);
        }
      }, 0);
    } catch (error) {
      console.error('[TaskDetailView] âŒ æ›´æ–°æ•…éšœçŠ¶æ€å¤±è´¥:', error);
      
      setTimeout(() => {
        try {
          promptAction.showToast({
            message: 'æ›´æ–°å¤±è´¥ï¼Œè¯·é‡è¯•',
            duration: 2000
          });
        } catch (toastError) {
          console.warn('[TaskDetailView] âš ï¸ Toastæ˜¾ç¤ºå¤±è´¥:', toastError);
        }
      }, 0);
    } finally {
      this.isUpdatingFlaw = false;
    }
  }

  getFlawStatusColor(flaw: AgvFlaw): string {
    if (flaw.confirmed) {
      return '#f56c6c'; // å·²ç¡®è®¤ - çº¢è‰²
    } else if (flaw.remark?.includes('ç–‘ä¼¼')) {
      return '#e6a23c'; // ç–‘ä¼¼æ•…éšœ - æ©™è‰²
    } else if (flaw.remark?.includes('è¯¯æŠ¥')) {
      return '#909399'; // è¯¯æŠ¥ - ç°è‰²
    } else {
      return '#409eff'; // å¾…å¤„ç† - è“è‰²
    }
  }

  getFlawStatusText(flaw: AgvFlaw): string {
    if (flaw.confirmed) {
      return 'å·²ç¡®è®¤';
    } else if (flaw.remark?.includes('ç–‘ä¼¼')) {
      return 'ç–‘ä¼¼æ•…éšœ';
    } else if (flaw.remark?.includes('è¯¯æŠ¥')) {
      return 'è¯¯æŠ¥';
    } else {
      return 'å¾…å¤„ç†';
    }
  }

  build() {
    Column() {
      // é¡¶éƒ¨å¯¼èˆª
      Row() {
        Button('â† è¿”å›')
          .fontSize(14)
          .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
          .backgroundColor('transparent')
          .onClick(() => {
            router.back();
          })
        
        Text('ä»»åŠ¡è¯¦æƒ…')
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .layoutWeight(1)
          .textAlign(TextAlign.Center)
      }
      .width('100%')
      .height(60)
      .padding({ left: 16, right: 16 })
      .backgroundColor('#ffffff')
      .border({ width: { bottom: 1 }, color: '#eeeeee' })

      if (this.loading) {
        // åŠ è½½çŠ¶æ€
        Column() {
          LoadingProgress()
            .width(50)
            .height(50)
            .color(AppConstants.COLORS.PRIMARY)
          
          Text('åŠ è½½ä¸­...')
            .fontSize(14)
            .fontColor(AppConstants.COLORS.TEXT_REGULAR)
            .margin({ top: 10 })
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
      } else {
        // ä¸»è¦å†…å®¹
        Row() {
          // å·¦ä¾§å›¾ç‰‡åŒºåŸŸ
          Column() {
            if (this.flaws.length > 0 && this.currentFlawIndex < this.flaws.length) {
              Image(this.flaws[this.currentFlawIndex].flawImage || '')
                .width('100%')
                .height(400)
                .objectFit(ImageFit.Contain)
                .backgroundColor('#f5f5f5')
                .border({ width: 1, color: '#dddddd' })
                .borderRadius(8)
            } else {
              Column() {
                Text('æš‚æ— æ•…éšœå›¾ç‰‡')
                  .fontSize(16)
                  .fontColor(AppConstants.COLORS.TEXT_REGULAR)
              }
              .width('100%')
              .height(400)
              .justifyContent(FlexAlign.Center)
              .alignItems(HorizontalAlign.Center)
              .backgroundColor('#f5f5f5')
              .border({ width: 1, color: '#dddddd' })
              .borderRadius(8)
            }

            // è¿›åº¦æ¡
            if (this.flaws.length > 0) {
              Row() {
                ForEach(this.flaws, (flaw: Flaw, index: number) => {
                  Button()
                    .width(12)
                    .height(12)
                    .borderRadius(6)
                    .backgroundColor(this.getFlawStatusColor(flaw))
                    .border({ 
                      width: index === this.currentFlawIndex ? 2 : 1, 
                      color: index === this.currentFlawIndex ? AppConstants.COLORS.PRIMARY : '#dddddd' 
                    })
                    .margin({ right: 8 })
                    .onClick(() => this.selectFlaw(index))
                }, (flaw: Flaw) => flaw.id.toString())
              }
              .width('100%')
              .padding(20)
              .justifyContent(FlexAlign.Center)
            }
          }
          .layoutWeight(1)
          .padding(20)

          // å³ä¾§ä¿¡æ¯åŒºåŸŸ
          Column() {
            // ä»»åŠ¡ä¿¡æ¯å¡ç‰‡
            if (this.task) {
              Column() {
                Text('ä»»åŠ¡ä¿¡æ¯')
                  .fontSize(16)
                  .fontWeight(FontWeight.Bold)
                  .margin({ bottom: 15 })

                Row() {
                  Text('ä»»åŠ¡ç¼–å·:')
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                    .width(80)
                  Text(this.task.taskNo)
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                }
                .width('100%')
                .margin({ bottom: 8 })

                Row() {
                  Text('ä»»åŠ¡åç§°:')
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                    .width(80)
                  Text(this.task.taskName)
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                }
                .width('100%')
                .margin({ bottom: 8 })



                Row() {
                  Text('æ‰§è¡Œäºº:')
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                    .width(80)
                  Text(this.task.executor)
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                }
                .width('100%')
              }
              .width('100%')
              .padding(15)
              .backgroundColor('#ffffff')
              .borderRadius(8)
              .border({ width: 1, color: '#eeeeee' })
              .margin({ bottom: 20 })
            }

            // æ•…éšœç»Ÿè®¡
            Column() {
              Text('æ•…éšœç»Ÿè®¡')
                .fontSize(16)
                .fontWeight(FontWeight.Bold)
                .margin({ bottom: 15 })

              Row() {
                Column() {
                  Text(this.flaws.length.toString())
                    .fontSize(24)
                    .fontWeight(FontWeight.Bold)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                  Text('æ€»æ•°')
                    .fontSize(12)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                }
                .layoutWeight(1)

                Column() {
                  Text(this.confirmedCount.toString())
                    .fontSize(24)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#f56c6c')
                  Text('å·²ç¡®è®¤')
                    .fontSize(12)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                }
                .layoutWeight(1)

                Column() {
                  Text(this.suspectedCount.toString())
                    .fontSize(24)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#e6a23c')
                  Text('ç–‘ä¼¼')
                    .fontSize(12)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                }
                .layoutWeight(1)

                Column() {
                  Text(this.falsePositiveCount.toString())
                    .fontSize(24)
                    .fontWeight(FontWeight.Bold)
                    .fontColor('#909399')
                  Text('è¯¯æŠ¥')
                    .fontSize(12)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                }
                .layoutWeight(1)
              }
              .width('100%')
            }
            .width('100%')
            .padding(15)
            .backgroundColor('#ffffff')
            .borderRadius(8)
            .border({ width: 1, color: '#eeeeee' })
            .margin({ bottom: 20 })

            // æ•…éšœåˆ—è¡¨
            Column() {
              Text('æ•…éšœåˆ—è¡¨')
                .fontSize(16)
                .fontWeight(FontWeight.Bold)
                .margin({ bottom: 15 })

              List() {
                ForEach(this.flaws, (flaw: Flaw, index: number) => {
                  ListItem() {
                    Row() {
                      Column() {
                        Text(flaw.flawName)
                          .fontSize(14)
                          .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                          .fontWeight(FontWeight.Medium)
                        Text(flaw.flawType)
                          .fontSize(12)
                          .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                          .margin({ top: 4 })
                      }
                      .alignItems(HorizontalAlign.Start)
                      .layoutWeight(1)

                      Text(this.getFlawStatusText(flaw))
                .fontSize(12)
                .fontColor('#ffffff')
                .backgroundColor(this.getFlawStatusColor(flaw))
                        .padding({ left: 8, right: 8, top: 4, bottom: 4 })
                        .borderRadius(12)
                    }
                    .width('100%')
                    .padding(12)
                    .backgroundColor(index === this.currentFlawIndex ? '#f0f9ff' : '#ffffff')
                    .border({ width: 1, color: index === this.currentFlawIndex ? AppConstants.COLORS.PRIMARY : '#eeeeee' })
                    .borderRadius(6)
                    .onClick(() => {
                      this.selectFlaw(index);
                      this.openFlawDetail(flaw);
                    })
                  }
                  .margin({ bottom: 8 })
                }, (flaw: Flaw) => flaw.id.toString())
              }
              .width('100%')
              .height(300)
            }
            .width('100%')
            .padding(15)
            .backgroundColor('#ffffff')
            .borderRadius(8)
            .border({ width: 1, color: '#eeeeee' })
          }
          .width(400)
          .padding(20)
        }
        .width('100%')
        .layoutWeight(1)
        .alignItems(VerticalAlign.Top)
      }

      // æ•…éšœè¯¦æƒ…æ¨¡æ€æ¡†
      if (this.showFlawDetail && this.selectedFlaw) {
        Stack() {
          Column() {
            // æ¨¡æ€æ¡†æ ‡é¢˜
            Row() {
              Text('æ•…éšœè¯¦æƒ…')
                .fontSize(18)
                .fontWeight(FontWeight.Bold)
                .layoutWeight(1)
              
              Button('âœ•')
                .fontSize(16)
                .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                .backgroundColor('transparent')
                .onClick(() => this.closeFlawDetail())
            }
            .width('100%')
            .padding(20)
            .border({ width: { bottom: 1 }, color: '#eeeeee' })

            // æ¨¡æ€æ¡†å†…å®¹
            Column() {
              // æ•…éšœå›¾ç‰‡
              Image(this.selectedFlaw.flawImage || '')
                .width('100%')
                .height(300)
                .objectFit(ImageFit.Contain)
                .backgroundColor('#f5f5f5')
                .border({ width: 1, color: '#dddddd' })
                .borderRadius(8)
                .margin({ bottom: 20 })

              // æ•…éšœä¿¡æ¯
              Row() {
                Column() {
                  Text('æ•…éšœåç§°')
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                    .margin({ bottom: 5 })
                  Text(this.selectedFlaw.flawName)
                    .fontSize(16)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                }
                .alignItems(HorizontalAlign.Start)
                .layoutWeight(1)

                Column() {
                  Text('æ•…éšœç±»å‹')
                    .fontSize(14)
                    .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                    .margin({ bottom: 5 })
                  Text(this.selectedFlaw.flawType)
                    .fontSize(16)
                    .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
                }
                .alignItems(HorizontalAlign.Start)
                .layoutWeight(1)
              }
              .width('100%')
              .margin({ bottom: 20 })

              // æ•…éšœæè¿°
              Column() {
                Text('æ•…éšœæè¿°')
                  .fontSize(14)
                  .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                  .margin({ bottom: 5 })
                Text(this.selectedFlaw.flawDesc || 'æš‚æ— æè¿°')
                  .fontSize(14)
                  .fontColor(AppConstants.COLORS.TEXT_PRIMARY)
              }
              .width('100%')
              .alignItems(HorizontalAlign.Start)
              .margin({ bottom: 20 })

              // å¤‡æ³¨è¾“å…¥
              Column() {
                Text('å¤‡æ³¨ä¿¡æ¯')
                  .fontSize(14)
                  .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                  .margin({ bottom: 5 })
                  .alignSelf(ItemAlign.Start)
                
                TextArea({
                  placeholder: 'è¯·è¾“å…¥å¤‡æ³¨ä¿¡æ¯ï¼ˆå¯é€‰ï¼‰',
                  text: this.flawRemark
                })
                  .width('100%')
                  .height(80)
                  .fontSize(14)
                  .borderRadius(6)
                  .backgroundColor('#F8F8F8')
                  .border({ width: 1, color: '#E0E0E0' })
                  .padding(12)
                  .onChange((value: string) => {
                    this.flawRemark = value;
                  })
              }
              .width('100%')
              .margin({ bottom: 20 })

              // çŠ¶æ€ç¡®è®¤
              Column() {
                Text('æ•…éšœç¡®è®¤')
                  .fontSize(14)
                  .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                  .margin({ bottom: 10 })

                Row() {
                  Button('ç¡®è®¤æ•…éšœ')
                    .fontSize(14)
                    .fontColor('#ffffff')
                    .backgroundColor(this.isUpdatingFlaw ? '#CCCCCC' : '#f56c6c')
                    .border({ width: 1, color: this.isUpdatingFlaw ? '#CCCCCC' : '#f56c6c' })
                    .enabled(!this.isUpdatingFlaw)
                    .onClick(() => {
                      if (this.selectedFlaw && !this.isUpdatingFlaw) {
                        this.updateFlawStatus(this.selectedFlaw.id, FlawStatus.CONFIRMED);
                      }
                    })

                  Button('ç–‘ä¼¼æ•…éšœ')
                    .fontSize(14)
                    .fontColor('#ffffff')
                    .backgroundColor(this.isUpdatingFlaw ? '#CCCCCC' : '#e6a23c')
                    .border({ width: 1, color: this.isUpdatingFlaw ? '#CCCCCC' : '#e6a23c' })
                    .margin({ left: 10 })
                    .enabled(!this.isUpdatingFlaw)
                    .onClick(() => {
                      if (this.selectedFlaw && !this.isUpdatingFlaw) {
                        this.updateFlawStatus(this.selectedFlaw.id, FlawStatus.SUSPECTED);
                      }
                    })

                  Button('è¯¯æŠ¥')
                    .fontSize(14)
                    .fontColor('#ffffff')
                    .backgroundColor(this.isUpdatingFlaw ? '#CCCCCC' : '#909399')
                    .border({ width: 1, color: this.isUpdatingFlaw ? '#CCCCCC' : '#909399' })
                    .margin({ left: 10 })
                    .enabled(!this.isUpdatingFlaw)
                    .onClick(() => {
                      if (this.selectedFlaw && !this.isUpdatingFlaw) {
                        this.updateFlawStatus(this.selectedFlaw.id, FlawStatus.FALSE_POSITIVE);
                      }
                    })
                }
                .width('100%')
                
                // æ›´æ–°çŠ¶æ€æç¤º
                if (this.isUpdatingFlaw) {
                  Row() {
                    LoadingProgress()
                      .width(16)
                      .height(16)
                      .color(AppConstants.COLORS.PRIMARY)
                    
                    Text('æ­£åœ¨æ›´æ–°...')
                      .fontSize(12)
                      .fontColor(AppConstants.COLORS.TEXT_REGULAR)
                      .margin({ left: 8 })
                  }
                  .width('100%')
                  .justifyContent(FlexAlign.Center)
                  .margin({ top: 12 })
                }
              }
              .width('100%')
              .alignItems(HorizontalAlign.Start)
            }
            .width('100%')
            .padding(20)
            .layoutWeight(1)
          }
          .width(800)
          .height(600)
          .backgroundColor('#ffffff')
          .borderRadius(8)
          .shadow({ radius: 12, color: 'rgba(0,0,0,0.2)', offsetX: 0, offsetY: 4 })
        }
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => this.closeFlawDetail())
      }
    }
    .width('100%')
    .height('100%')
    .backgroundColor(AppConstants.COLORS.BACKGROUND_BASE)
  }
}