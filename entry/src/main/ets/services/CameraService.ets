import http from '@ohos.net.http';
import { HttpUtil } from '../utils/HttpUtil';
import { AppConstants } from '../constants/AppConstants';

// æ‘„åƒå¤´è®¾å¤‡æ¥å£
export interface CameraDevice {
  id: string;
  name: string;
  status?: string;
  ip?: string;
  port?: number;
  channel?: number;
}

// æ‘„åƒå¤´ä¿¡æ¯æ¥å£ï¼ˆç”¨äºUIæ˜¾ç¤ºï¼‰
export interface CameraInfo {
  id: string;
  name: string;
  url: string;
  status: string;
}

// æ‘„åƒå¤´æœåŠ¡å“åº”æ•°æ®æ¥å£
interface CameraResponseData {
  items: CameraDevice[];
  total: number;
}

// æ‘„åƒå¤´æœåŠ¡å“åº”æ¥å£
interface CameraListResponse {
  code: number;
  msg: string;
  data: CameraResponseData;
}

// æ—¥å¿—ä¿¡æ¯æ¥å£ï¼ˆç§»é™¤ç´¢å¼•ç­¾åï¼‰
interface LogInfo {
  message?: string;
  data?: string;
}

// è®¾å¤‡æ—¥å¿—ä¿¡æ¯æ¥å£
interface DeviceLogInfo {
  deviceCount: number;
  deviceIds: string[];
}

// æ‘„åƒå¤´æ—¥å¿—ä¿¡æ¯æ¥å£
interface CameraLogInfo {
  deviceId: string;
  cameraName: string;
  streamUrl: string;
}

// æµURLæ—¥å¿—ä¿¡æ¯æ¥å£
interface StreamLogInfo {
  cameraId: string;
  streamUrl: string;
}

// åˆ·æ–°URLæ—¥å¿—ä¿¡æ¯æ¥å£
interface RefreshLogInfo {
  cameraId: string;
  timestamp: number;
  refreshUrl: string;
}

// æ‘„åƒå¤´ä¿¡æ¯é¡¹æ¥å£
interface CameraInfoItem {
  id: string;
  name: string;
}

// æ‘„åƒå¤´åˆ—è¡¨æ—¥å¿—ä¿¡æ¯æ¥å£
interface CameraListLogInfo {
  totalCount: number;
  cameras: CameraInfoItem[];
}

// è¿æ¥æµ‹è¯•æ—¥å¿—ä¿¡æ¯æ¥å£
interface ConnectionLogInfo {
  isConnected: boolean;
  deviceCount: number;
}

/**
 * æ‘„åƒå¤´æœåŠ¡ç±»
 * è´Ÿè´£ç®¡ç†æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨è·å–å’Œè§†é¢‘æµURLç”Ÿæˆ
 */
export class CameraService {
  // æ‘„åƒå¤´æœåŠ¡è®¤è¯å¤´
  private static readonly AUTH_HEADER = 'Basic YWRtaW4xMjM6QWRtaW5AMTIz';
  
  /**
   * è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨
   * @returns Promise<CameraDevice[]> æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨
   */
  static async getCameraDevices(): Promise<CameraDevice[]> {
    try {
      console.info('[CameraService] ğŸ“¹ å¼€å§‹è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨');
      
      const url = `${AppConstants.CAMERA_BASE_URL}/devices?page=1&size=999&status=&id&name`;
      console.info('[CameraService] ğŸ“¹ è¯·æ±‚URL:', url);
      
      const response = await HttpUtil.request(url, {
        method: http.RequestMethod.GET,
        headers: {
          'Authorization': CameraService.AUTH_HEADER,
          'Content-Type': 'application/json'
        },
        timeout: AppConstants.REQUEST_TIMEOUT
      });
      
      console.info('[CameraService] ğŸ“¹ æ‘„åƒå¤´æœåŠ¡å“åº”:', JSON.stringify({
        code: response.code,
        dataType: typeof response.data,
        hasData: response.data ? true : false
      }));
      
      if (response.code === 200) {
        // æ‘„åƒå¤´APIç›´æ¥è¿”å›æ•°æ®ï¼Œä¸æ˜¯åŒ…è£…åœ¨HttpResponseä¸­
        let responseData: CameraResponseData;
        
        if (response.data) {
          // å¦‚æœdataå­˜åœ¨ï¼Œè¯´æ˜æ˜¯åŒ…è£…çš„å“åº”
          responseData = response.data as CameraResponseData;
        } else {
          // å¦‚æœdataä¸å­˜åœ¨ï¼Œå¯èƒ½éœ€è¦ä»åŸå§‹å“åº”ä¸­è§£æ
          console.warn('[CameraService] âš ï¸ å“åº”æ•°æ®ä¸ºç©ºï¼Œå°è¯•å…¶ä»–è§£ææ–¹å¼');
          return [];
        }
        
        if (responseData && responseData.items) {
          const devices = responseData.items;
          const logInfo: DeviceLogInfo = {
            deviceCount: devices.length,
            deviceIds: devices.map((d: CameraDevice) => d.id)
          };
          console.info('[CameraService] âœ… æˆåŠŸè·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨:', JSON.stringify(logInfo));
          return devices;
        }
      }
      
      console.warn('[CameraService] âš ï¸ æ‘„åƒå¤´æœåŠ¡è¿”å›å¼‚å¸¸:', JSON.stringify({
         code: response.code,
         msg: response.msg,
         data: response.data
       }));
        return [];
    } catch (error) {
      console.error('[CameraService] âŒ è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨å¤±è´¥:', error);
      throw new Error(`è·å–æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨å¤±è´¥: ${error}`);
    }
  }
  
  /**
   * å°†æ‘„åƒå¤´è®¾å¤‡è½¬æ¢ä¸ºUIæ˜¾ç¤ºä¿¡æ¯
   * @param devices æ‘„åƒå¤´è®¾å¤‡åˆ—è¡¨
   * @returns CameraInfo[] UIæ˜¾ç¤ºçš„æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨
   */
  static convertToCameraInfo(devices: CameraDevice[]): CameraInfo[] {
    return devices.map((device, index) => {
      const cameraInfo: CameraInfo = {
        id: device.id,
        name: device.name || `æ‘„åƒå¤´${index + 1}`,
        url: CameraService.generateStreamUrl(device.id),
        status: device.status || 'unknown'
      };
      
      const logInfo: CameraLogInfo = {
        deviceId: device.id,
        cameraName: cameraInfo.name,
        streamUrl: cameraInfo.url
      };
      console.info('[CameraService] ğŸ¥ ç”Ÿæˆæ‘„åƒå¤´ä¿¡æ¯:', JSON.stringify(logInfo));
      
      return cameraInfo;
    });
  }
  
  /**
   * ç”Ÿæˆè§†é¢‘æµURL
   * @param cameraId æ‘„åƒå¤´ID
   * @returns string è§†é¢‘æµURL
   */
  static generateStreamUrl(cameraId: string): string {
    const streamUrl = `${AppConstants.WEBRTC_BASE_URL}/live/${cameraId}_01.flv`;
    const logInfo: StreamLogInfo = {
      cameraId: cameraId,
      streamUrl: streamUrl
    };
    console.info('[CameraService] ğŸ”— ç”Ÿæˆè§†é¢‘æµURL:', JSON.stringify(logInfo));
    return streamUrl;
  }
  
  /**
   * ç”Ÿæˆå¸¦æ—¶é—´æˆ³çš„è§†é¢‘æµURLï¼ˆç”¨äºåˆ·æ–°ï¼‰
   * @param cameraId æ‘„åƒå¤´ID
   * @returns string å¸¦æ—¶é—´æˆ³çš„è§†é¢‘æµURL
   */
  static generateRefreshStreamUrl(cameraId: string): string {
    const timestamp = Date.now();
    const refreshUrl = `${CameraService.generateStreamUrl(cameraId)}?t=${timestamp}`;
    const logInfo: RefreshLogInfo = {
      cameraId: cameraId,
      timestamp: timestamp,
      refreshUrl: refreshUrl
    };
    console.info('[CameraService] ğŸ”„ ç”Ÿæˆåˆ·æ–°è§†é¢‘æµURL:', JSON.stringify(logInfo));
    return refreshUrl;
  }
  
  /**
   * è·å–æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨ï¼ˆè®¾å¤‡åˆ—è¡¨ + UIä¿¡æ¯è½¬æ¢çš„ç»„åˆæ–¹æ³•ï¼‰
   * @returns Promise<CameraInfo[]> æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨
   */
  static async getCameraInfoList(): Promise<CameraInfo[]> {
    try {
      console.info('[CameraService] ğŸ¬ å¼€å§‹è·å–æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨');
      
      const devices = await CameraService.getCameraDevices();
      const cameraInfoList = CameraService.convertToCameraInfo(devices);
      
      const logInfo: CameraListLogInfo = {
        totalCount: cameraInfoList.length,
        cameras: cameraInfoList.map((c: CameraInfo): CameraInfoItem => ({ id: c.id, name: c.name }))
      };
      console.info('[CameraService] âœ… æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨è·å–æˆåŠŸ:', JSON.stringify(logInfo));
      
      return cameraInfoList;
    } catch (error) {
      console.error('[CameraService] âŒ è·å–æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨å¤±è´¥:', error);
      throw new Error(`è·å–æ‘„åƒå¤´ä¿¡æ¯åˆ—è¡¨å¤±è´¥: ${error}`);
    }
  }
  
  /**
   * æµ‹è¯•æ‘„åƒå¤´æœåŠ¡è¿æ¥
   * @returns Promise<boolean> è¿æ¥æµ‹è¯•ç»“æœ
   */
  static async testConnection(): Promise<boolean> {
    try {
      console.info('[CameraService] ğŸ” æµ‹è¯•æ‘„åƒå¤´æœåŠ¡è¿æ¥');
      
      const devices = await CameraService.getCameraDevices();
      const isConnected = devices.length >= 0; // å³ä½¿æ²¡æœ‰è®¾å¤‡ï¼Œèƒ½æ­£å¸¸å“åº”ä¹Ÿç®—è¿æ¥æˆåŠŸ
      
      const logInfo: ConnectionLogInfo = {
        isConnected: isConnected,
        deviceCount: devices.length
      };
      console.info('[CameraService] âœ… æ‘„åƒå¤´æœåŠ¡è¿æ¥æµ‹è¯•ç»“æœ:', JSON.stringify(logInfo));
      
      return isConnected;
    } catch (error) {
      console.error('[CameraService] âŒ æ‘„åƒå¤´æœåŠ¡è¿æ¥æµ‹è¯•å¤±è´¥:', error);
      return false;
    }
  }
}